/*
 * esp_ap_web.c
 *
 *  Created on: Nov 21, 2025
 *      Author: pavan
 */

#include "esp_ap_web.h"
#include <string.h>
#include <stdio.h>

#define RXBUF_SIZE 1024
static UART_HandleTypeDef *esp_huart;
static volatile uint32_t latest_distance_cm = 0;

/* rx ring buffer */
static uint8_t rxbuf[RXBUF_SIZE];
static volatile uint16_t rx_head = 0;
static volatile uint16_t rx_tail = 0;

/* -------------------- RX RING BUFFER --------------------- */
static void rx_push(uint8_t b) {
    rxbuf[rx_head++] = b;
    if (rx_head >= RXBUF_SIZE) rx_head = 0;
}

static uint16_t rx_count(void) {
    if (rx_head >= rx_tail) return (rx_head - rx_tail);
    return (RXBUF_SIZE - rx_tail) + rx_head;
}

static uint8_t rx_peek_char(uint16_t idx) {
    uint16_t pos = rx_tail + idx;
    if (pos >= RXBUF_SIZE) pos -= RXBUF_SIZE;
    return rxbuf[pos];
}

static uint8_t rx_pop(void) {
    uint8_t b = rxbuf[rx_tail++];
    if (rx_tail >= RXBUF_SIZE) rx_tail = 0;
    return b;
}

/* -------------------- UART SEND -------------------------- */
static void esp_send_raw(const char* s) {
    HAL_UART_Transmit(esp_huart, (uint8_t*)s, strlen(s), 2000);
}

/* -------------------- INITIALISATION ---------------------- */
void ESPAP_Init(UART_HandleTypeDef *huart) {
    esp_huart = huart;

    /* DO NOT start UART receive here.
       main.c correctly starts:
       HAL_UART_Receive_IT(&huart2, &esp_rx_tmp, 1);
    */
}

/* -------------------- BASIC AT COMMANDS ------------------- */
void ESPAP_Reset(void) {
    esp_send_raw("AT+RST\r\n");
}

void ESPAP_SendAT(void) {
    esp_send_raw("AT\r\n");
}

void ESPAP_SetAPMode(void) {
    esp_send_raw("AT+CWMODE=2\r\n");   // 2 = SoftAP
}

void ESPAP_SetAP(const char* ssid, const char* pwd) {
    char cmd[128];
    if (pwd == NULL || pwd[0] == '\0') {
        snprintf(cmd, sizeof(cmd), "AT+CWSAP=\"%s\",\"\",5,3\r\n", ssid);
    } else {
        snprintf(cmd, sizeof(cmd), "AT+CWSAP=\"%s\",\"%s\",5,3\r\n", ssid, pwd);
    }

    esp_send_raw(cmd);

    /* IMPORTANT: SoftAP takes 2â€“4 seconds to start */
    HAL_Delay(3000);
}

void ESPAP_EnableMUX(void) {
    esp_send_raw("AT+CIPMUX=1\r\n");
}

void ESPAP_StartServer(uint16_t port) {
    char cmd[64];
    snprintf(cmd, sizeof(cmd), "AT+CIPSERVER=1,%u\r\n", (unsigned)port);
    esp_send_raw(cmd);
    HAL_Delay(500);
}

void ESPAP_UpdateDistance(uint32_t d) {
    latest_distance_cm = d;
}

/* -------------------- SEND HTML PAGE ---------------------- */
static void reply_with_distance(int linkid) {
    char body[256];
    int blen = snprintf(body, sizeof(body),
        "<html>"
        "<head><meta http-equiv=\"refresh\" content=\"1\"></head>"
        "<body><h2>Object at: %lu cm</h2></body>"
        "</html>",
        (unsigned long)latest_distance_cm
    );

    char sendcmd[64];
    snprintf(sendcmd, sizeof(sendcmd),
        "AT+CIPSEND=%d,%d\r\n", linkid, blen);

    esp_send_raw(sendcmd);
    HAL_Delay(60);  // wait for ">"

    HAL_UART_Transmit(esp_huart, (uint8_t*)body, blen, 1000);
    HAL_Delay(20);

    char closecmd[32];
    snprintf(closecmd, sizeof(closecmd), "AT+CIPCLOSE=%d\r\n", linkid);
    esp_send_raw(closecmd);
}

/* -------------------- PARSER FOR +IPD --------------------- */
static void process_rx_stream(void) {
    while (rx_count() > 5) {
        uint16_t cnt = rx_count();
        uint16_t i;
        uint8_t found = 0;

        /* search for "+IPD," */
        for (i = 0; i + 4 < cnt; i++) {
            if (rx_peek_char(i) == '+' &&
                rx_peek_char(i+1) == 'I' &&
                rx_peek_char(i+2) == 'P' &&
                rx_peek_char(i+3) == 'D' &&
                rx_peek_char(i+4) == ',') {

                found = 1;
                break;
            }
        }

        if (!found) {
            /* remove processed old data */
            if (cnt > 5)
                for (uint16_t k = 0; k < cnt - 5; k++) rx_pop();
            break;
        }

        /* pop everything before +IPD */
        for (uint16_t k = 0; k < i; k++) rx_pop();

        /* pop "+IPD," */
        for (int k = 0; k < 5; k++) rx_pop();

        /* parse link ID */
        int linkid = 0;
        while (rx_count() && rx_peek_char(0) >= '0' && rx_peek_char(0) <= '9') {
            linkid = linkid * 10 + (rx_pop() - '0');
        }

        /* skip comma */
        if (rx_count() && rx_peek_char(0) == ',') rx_pop();

        /* skip length until ':' */
        while (rx_count()) {
            uint8_t c = rx_pop();
            if (c == ':') break;
        }

        /* ignore payload, just respond */
        reply_with_distance(linkid);
    }
}

/* -------------------- BYTE RECEIVED CALLBACK --------------- */
void ESPAP_HandleUARTByte(uint8_t b) {
    rx_push(b);
    process_rx_stream();
}
