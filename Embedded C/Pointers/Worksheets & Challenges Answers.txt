1. Pointer Declaration and Initialization
Goal: Understand how to declare a pointer and store the address of a variable.

Activity:

Declare an integer variable: int a = 5;
Declare a pointer to int: int *ptr;
Assign the address of a to ptr: ptr = &a;
Print both a and *ptr using printf.



#include<stdio.h>
int main(){
    int a=5;
    int *ptr;
    ptr=&a;
    printf("%d\n",a);
    printf("%d\n",ptr);
    printf("%d",*ptr);
    return 0;
}



2. Using & (Address-of) Operator
Goal: Learn how to find and print the memory address of variables.

Activity:

Declare variables of different types: int x;, float y;, char z;
Print their memory addresses using &x, &y, and &z.



#include<stdio.h>
int main(){
    int a=5;
    char b='p';
    float z=5;
    int *ptr=&a;
    printf("%p\n",ptr);
    char *ptr1=&b;
    printf("%p\n",ptr1);
    float *ptr2=&z;
    printf("%p",ptr2);
    return 0;
}



3. Using * (Dereference) Operator
Goal: Learn how to access or modify a variable's value using a pointer.

Activity:

Declare int a = 10;
Log Session int *p = &a;
Change the value at the pointer: *p = 20;
Print a and *p to verify both are 20.



#include<stdio.h>
int main(){
    int a=10;
    int *ptr=&a;
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
    printf("%d\n",a);
    *ptr=20;
    printf("%p\n",ptr);
    printf("%d\n",*ptr);
    printf("%d",a);
    return 0;
}



4. Swapping Two Numbers Using Pointers
Goal: Understand how to pass variables by reference to functions using pointers.

Activity:

Write a swap function: void swap(int *a, int *b)
In main(), declare two integers and call swap(&x, &y);
Print values before and after swapping.



#include<stdio.h>

void swap(int *a,int *b){
    int temp=*a;
    *a=*b;
    *b=temp;
    printf("%d %d\n",*a,*b);
}

int main(){
    int a=10,b=5;
    printf("%d %d\n",a,b);
    swap(&a,&b);
    printf("%d %d\n",a,b);
    return 0;
}



5. Pointer Arithmetic with Arrays
Goal: Learn how to access array elements using pointer arithmetic.

Activity:

Declare: int arr[5] = {10, 20, 30, 40, 50};
Use int *p = arr;
Use a loop to print all elements via *(p + i).



#include<stdio.h>
int main(){
    int arr[5]={10,20,30,40,50};
    int *ptr = arr;
    for(int i=0;i<5;i++){
        printf("%d\n",*(ptr+i));
    }
    return 0;
}





6. Array Index vs Pointer Arithmetic
Goal: Understand that arr[i] and *(arr + i) give the same result.

Activity:

Use both arr[i] and *(arr + i) to print array elements.
Confirm outputs are the same.




#include<stdio.h>
int main(){
    int arr[5]={10,20,30,40,50};
    for(int i=0;i<5;i++){
        printf("%d\n",*(arr+i));
    }
    return 0;
}




7. Modify Array Elements Using Pointers
Goal: Learn to modify values in an array using pointer operations.

Activity:

Log Session int arr[] = {2, 4, 6};
Use pointer arithmetic to increase each element by 1.
Print modified array.



#include<stdio.h>
int main(){
    int arr[5]={10,20,30,40,50};
    int *ptr=arr;
    for(int i=0;i<5;i++){
        printf("%d\n",*(ptr+i));
    }
    printf("\n");
    *(ptr+3)=80;
    for(int i=0;i<5;i++){
        printf("%d\n",*(ptr+i));
    }
    return 0;
}



8. NULL Pointer Safety
Goal: Learn to avoid dereferencing NULL pointers.

Activity:

Declare: int *p = NULL;
Use a condition if (p != NULL) before dereferencing.
Later, assign p = &a; and access safely.


#include<stdio.h>
int main(){
    int arr[5]={10,20,30,40,50};
    int *ptr=NULL;
    if(ptr!=NULL){
        for(int i=0;i<5;i++){
            printf("%d\n",*(ptr + i));
        }
    }
    else {
        printf("Pointer is NULL, assigning a valid address now.\n");
        ptr = arr;  
        if (ptr != NULL) {
            for (int i = 0; i < 5; i++) {
                printf("%d\n", *(ptr + i));
            }
        }
    }
    return 0;
}



9. Passing Array to Function
Goal: Learn how arrays are passed to functions as pointers.

Activity:

Write void display(int *arr, int n);
Inside the function, loop using pointer arithmetic to print elements.





#include<stdio.h>

void display(int *arr,int n){
    for(int i=0;i<n;i++){
        printf("%d\n",*(arr+i));
    }
}

int main(){
    int n;
    printf("Enter n value: ");
    scanf("%d",&n);
    int arr[n];
    printf("Enter array elements: ");
    for(int i=0;i<n;i++)
    scanf("%d",&arr[i]);
    display(arr,n);
    return 0;
}



10. Visualizing Memory Addresses
Goal: Visualize how memory is arranged for variables.

Activity:

Declare three local variables.
Print their addresses using printf.
Observe the increasing/decreasing pattern.



#include<stdio.h>
int main(){
    int a,b,c;
    int *p1=&a;
    int *p2=&b;
    int *p3=&c;
    printf("%p\n",p1);
    printf("%p\n",p2);
    printf("%p\n",p3);
    printf("Increasing\n");
    printf("%p\n",(p1+1));
    printf("%p\n",(p2+1));
    printf("%p\n",(p3+1));
    return 0;
}



11. Pointer to Pointer (int **)
Goal: Learn how to use a pointer to another pointer.

Activity:

Declare int a = 5;, int *p = &a;, and int **pp = &p;
Print a, *p, and **pp to understand levels of indirection.



#include<stdio.h>
int main(){
    int a=5;
    int *p=&a;
    int **pp=&p;
    printf("%d\n%d\n%d\n",a,*p,**pp);
}



12. Garbage Pointer
Goal: Understand what happens when a pointer is used without initialization.

Activity:

Declare an uninitialized pointer int *p;
Try printing *p and observe the issue (garbage value or crash).
Then fix by assigning a valid address.


#include<stdio.h>
int main(){
    int *p;
    int a=10;
    int *p1=&a;
    printf("%d\n",a);
    printf("%d\n",*p1);
    printf("%d",*p);
    return 0;
}


13. Pointer Type Compatibility
Goal: Understand the importance of matching pointer types.

Activity:

Declare int *ip; and float *fp;
Try assigning fp = ip; and observe compiler warning.
Correct the mismatch using proper types or casting.



#include<stdio.h>
int main(){
    int a=5;
    int *ip=&a;
    printf("%d\n%d\n",a,*ip);
    float b = (float)a;
    float *fp = &b;
    printf("%f",*fp);
    return 0;
}





Worksheet-2
-----------------




1. Pointer Declaration and Initialization
Goal: Declare pointers for various data types and initialize them properly to point to existing variables or dynamically allocated memory. Use pointer arithmetic and typecasting appropriately.

Activity:

Declare pointers to different data types (int, float, char).
Dynamically allocate memory for these pointers.
Assign addresses of variables to pointers and access their values through the pointers.
Perform pointer arithmetic to move through allocated memory blocks.
Use typecasting to convert pointers between compatible types.




#include<stdio.h>
int main(){
    int a=10;
    char b='P';
    float c=7.6;
    
    int *p1=&a;
    char *p2=&b;
    float *p3=&c;
    
    printf("%d\n",*p1);
    printf("%c\n",*p2);
    printf("%.2f\n",*p3);
}



2. Array and Pointer Arithmetic
Goal: Traverse and manipulate arrays by using pointers and pointer arithmetic instead of array indexing.

Activity:

Log Session an array of integers.
Use a pointer to iterate through the array elements by incrementing the pointer.
Perform operations like summing the elements or modifying them using only the pointer (no array indices).
Implement a function that receives a pointer and size to reverse the array elements in place.



#include<stdio.h>

void reverse(int *arr, int n){
    int *start = arr;
    int *end = arr + n - 1;

    while (start < end) {
        int temp = *start;
        *start = *end;
        *end = temp;

        start++;
        end--;
    }
}

int main(){
    int n;
    printf("Enetr n value: ");
    scanf("%d",&n);
    int arr[n];
    printf("Enter aray elements: ");
    for(int i=0;i<n;i++)
    scanf("%d",&arr[i]);
    reverse(arr,n);
    printf("Reversed array: ");
    for(int i=0;i<n;i++){
        printf("%d ",arr[i]);
    }
    return 0;
}




3. Pointer to Pointer (Double Pointer)
Goal: Understand how to use double pointers for indirect referencing and dynamic memory management.

Activity:

Declare a double pointer and use it to dynamically allocate memory for a single variable or an array.
Access and modify the allocated memory via the double pointer.
Pass double pointers to functions to dynamically allocate or modify memory inside the function.







4. Pointer and Function
Goal: Use pointers to pass variables or arrays to functions so that the function can modify the original data.

Activity:

Write a function that takes pointers as parameters to swap two integer variables.
Log Session a function that modifies the elements of an array via a pointer.
Pass a pointer to a function to update the contents of a structure or a dynamically allocated memory block.









Worksheet-3
----------------


1. Pointer and Array Behavior
Goal: Analyze how pointers and arrays differ in memory referencing and sizeof operations in embedded systems.
Activity:

Declare an integer array with predefined elements:

int arr[5] = {10, 20, 30, 40, 50};

Declare an integer pointer and assign it to the array's base address:

int *ptr = arr;

Print the values of the array name, the pointer, and the address of the array.
Use sizeof() on the array and pointer and observe differences.
Access the elements via both array indexing and pointer arithmetic, and print them.



#include<stdio.h>
int main(){
    int arr[]={10,20,30,40,50};
    int*ptr= arr;
    int n=sizeof(arr)/sizeof(arr[0]);
    printf("%d\n",*arr);
    printf("%p\n",*(&arr));
    printf("%d\n",*ptr);
    printf("%p\n",ptr);
    for(int i=0;i<n;i++){
        printf("%d\n",*(ptr+i));
    }
    return 0;
}




2. Accessing Multi-Dimensional Arrays with Pointers
Goal: Implement pointer arithmetic to traverse a 2D sensor data array efficiently without nested loops.
Activity:
 
Define a 3x3 integer matrix representing sensor readings:

int sensors[3][3] = {
  {100, 101, 102},
  {110, 111, 112},
  {120, 121, 122}
};

Assign a pointer to the first element of the matrix:

int *p = &sensors[0][0];

Use a single loop and pointer arithmetic to iterate over the matrix elements.
Print each sensor value accessed via the pointer.



Method-I
-----------


#include<stdio.h>

int main(){
    int arr[3][3]={{100,200,300},{400,500,600},{700,800,900}};
    int *ptr=&arr[0][0];
    for(int i=0;i<9;i++){
        printf("%3d ", *(ptr + i));
    if ((i + 1) % 3 == 0) printf("\n");
    }
return 0;
}



Method-II
----------

#include<stdio.h>

int main(){
    int arr[3][3]={{100,200,300},{400,500,600},{700,800,900}};
    int *ptr=&arr[0][0];
    for(int i=0;i<9;i++){
        printf("%d",*(ptr+i));
    }
return 0;
}



3. Working with Const and Volatile Pointers
Goal: Demonstrate how const and volatile qualifiers affect pointer behavior in hardware register access.
Activity:

Define a dummy hardware register address using #define:

#define REG_BASE 0x40000000

Declare pointers with different qualifiers:

volatile uint32_t *reg_modifiable = (uint32_t *)REG_BASE;
const uint32_t *reg_readonly = (const uint32_t *)REG_BASE;
const volatile uint32_t *reg_const_volatile = (const volatile uint32_t *)REG_BASE;

Attempt to write to and read from each pointer and note compiler behavior.



4. Void Pointers and Memory Copying
Goal: Use void pointers to create a generic memory copying utility function for embedded data types.
Activity:

Declare a function mem_copy(void *dest, const void *src, size_t n) that copies n bytes from src to dest:

void mem_copy(void *dest, const void *src, size_t n);

Within the function, use char * pointers to copy data byte-by-byte.
Test the function by copying an array of integers and an array of floats.






Challenges
---------------


1. How can you find the size of a data type without using the sizeof operator, using pointer arithmetic?

#include<stdio.h>
int main(){
    int a;
    int* ptr=&a;
    int *p1=ptr+1;
    int g=(char*)p1-(char*)ptr;
    printf("%d",g);
}



2.Design a function that determines if two pointers point to the same array.

#include<stdio.h>

int isSameArray(int *p1,int *p2){
    return p1==p2;
}

int main(){
    int n;
    printf("Enter n value: ");
    scanf("%d",&n);
    int arr[n];
    printf("Enter array elements: ");
    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    int *ptr1=arr;
    int *ptr2=arr;
    if (isSameArray(ptr1, ptr2))
        printf("Both pointers point to the same array.\n");
    else
        printf("Pointers do not point to the same array.\n");

    return 0;
}




3.Log Session a function that counts the number of elements in an array using pointer arithmetic, without utilizing loop constructs.

#include<stdio.h>

int isCount(int *start,int *end){
    if(start==end)
    return 0;
    return 1+isCount(start+1,end);
}

int main(){
    int arr[]={1,2,3,4,5,6,7,8,8,76,6,6,6,9};
    int size=(sizeof(arr)/sizeof(arr[0]));
    int count=isCount(arr,arr+size);
    printf("Count is: %d",count);
    return 0;
}




4. Implement a program that swaps two strings using pointers to pointers.


#include <stdio.h>

void swap(char **x, char **y) {
    char *temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    char *a = "Hemanth";
    char *b = "Poojith";
    printf("Before swap: a = %s, b = %s\n", a, b);
    swap(&a, &b);
    printf("After swap:  a = %s, b = %s\n", a, b);
    return 0;
}






5. Log Session a function that segregates even and odd values of an integer array using pointers.

#include<stdio.h>

void isEvenOdd(int *arr,int n){
    int *ptr=arr;
    for(int i=0;i<n;i++){
        if(*(ptr+i)%2==0){
            printf("Even:%d\n",*(ptr+i));
        }
        else{
            printf("odd:%d\n",*(ptr+i));
        }
    }
}

int main(){
    int arr[]={1,2,3,4,5,6};
    int n=sizeof(arr)/sizeof(arr[0]);
    isEvenOdd(arr,n);
    return 0;
}




6. Design a program to concatenate two strings without using standard library functions, only pointers.

#include<stdio.h>

void concat(char *x,char *y,char *result){
    while(*x!='\0'){
        *result=*x;
        result++;
        x++;
    }
    while(*y!='\0'){
        *result=*y;
        result++;
        y++;
    }
    *result='\0';
}

int main(){
    char a[100],b[100],result[100];
    printf("Enter 2 strings: ");
    scanf("%s %s",a,b);
    concat(a,b,result);
    printf("Concatenated string: %s\n", result);
    return 0;
}




