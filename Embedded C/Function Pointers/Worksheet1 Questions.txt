Worksheet1
-----------------

1.Mathematical Operations with Function Pointers
Log Session four simple mathematical functions (add, subtract, multiply, divide) that accept two integer arguments and return an integer.
Use a single function pointer to dynamically select and execute one of these operations based on user input.

2.Sorting Algorithms Selector
Implement three sorting functions (bubbleSort, selectionSort, insertionSort) that sort an integer array.
Store pointers to these sorting functions in an array of function pointers.
Prompt the user to choose a sorting method, and use the selected function pointer to sort a user-provided integer array.


3.Callback Function Array Processing
Define a function processArray that accepts an integer array, its size, and a callback function as arguments.
Implement callback functions (increment, doubleValue) that modify array elements in different ways.
Demonstrate invoking processArray with different callback functions.


4.Menu-driven Calculator Using Function Pointers
Implement mathematical operations (power, modulo, squareRoot) as separate functions.
Store these operation functions in a function pointer array.
Provide a user-interactive menu to select and execute the chosen operation on input values.


5.State Machine Implementation
Implement a basic state machine (initState, runState, stopState, errorState) with each state represented by a separate function.
Use function pointers to transition between states based on user input or internal conditions.
Demonstrate state transitions clearly in your programâ€™s output.


6.Event Handling System
Define events such as buttonPressEvent, sensorTriggerEvent.
Implement handler functions for these events.
Log Session an array of function pointers mapping each event to its corresponding handler function.
Simulate event triggers, calling the appropriate handler through function pointers.


7.Interrupt Handler Simulation
Log Session several interrupt handler functions (e.g., timerInterrupt, keyboardInterrupt, errorInterrupt).
Map these interrupt handlers using an array of function pointers.
Simulate interrupts by invoking appropriate interrupt handlers using their pointers based on interrupt numbers entered by the user.


8.Generic Find Function
Implement a generic function find that takes an integer array, its size, and a function pointer as a condition.
Log Session condition functions (e.g., isEven, isPositive, isPrime).
Use find to identify and print the first element matching the provided condition.


9.Dynamic Logging Mechanism
Implement three logging functions (consoleLog, fileLog, networkLog) with a common signature.
Allow the program to select the appropriate logging method dynamically through function pointers.
Demonstrate switching between logging methods at runtime based on user input.


10.Math Function Framework
Write wrapper functions around standard mathematical functions (sin, cos, tan, log) with the same function prototype.
Store pointers to these functions in an array.
Provide an interface for users to select and execute a math function on a given floating-point input.


11.Function Pointer as Return Value
Implement multiple arithmetic functions (add, subtract, multiply).
Write a function getOperation(char *name) that takes a string (like "add" or "subtract") and returns a pointer to the corresponding function.
Use this return value to perform the selected operation on user-provided numbers.


12.Function Pointer Array for String Operations
Implement several string manipulation functions (reverseString, toUpperCase, countVowels), each accepting a string argument.
Store these functions in an array of function pointers.
Prompt the user to choose an operation and apply it to their input string using the selected function pointer.


13.Passing Function Pointers to Standard Algorithms
Define a structure representing a record (e.g., struct Person { char name[30]; int age; }).
Implement multiple comparison functions for sorting (e.g., by name, by age).
Use the C standard library function qsort, passing these comparison functions as function pointers to sort an array of records in different ways.


14.Chained Function Pointer Calls
Write several functions that transform an integer (e.g., doubleValue, increment, square).
Log Session an array of function pointers representing a pipeline of operations.
Pass a number through the pipeline by applying each function in sequence, using the array of pointers.


15.Multi-dimensional Function Pointer Array
Define arithmetic functions for both int and float types (e.g., intAdd, floatAdd).
Organize the function pointers in a two-dimensional array:
First dimension: operation type (arithmetic, bitwise)
Second dimension: data type (int, float)
Demonstrate calling the correct function based on selected type and operation.


16.Recursive Function Pointer
Implement a recursive function (such as factorial or Fibonacci) using a function pointer variable instead of directly calling the function by name.
Show that the recursion works correctly using only the pointer.


17.Array of Function Pointers in a Structure
Define a structure (e.g., Calculator) that contains an array of function pointers for operations (add, subtract, multiply).
Instantiate the structure and use it to call the various operations on input values, demonstrating how the structure can perform different calculations.


18.Replace Switch-Case with Function Pointer Table
Simulate a command-based application where each command is represented by a number.
Instead of using a large switch-case block to handle commands, create a function pointer table.
Use the input command number as an index to call the corresponding handler function via the function pointer table.