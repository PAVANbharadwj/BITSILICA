Concepts
---------------------

About Structures

In C programming, a structure (struct) is a user-defined data type that lets you group variables of different types into a single unit. Structures are essential in embedded systems programming, where tight memory control, hardware-level data access, and modular design are critical.

This book introduces structures from the ground up, covering how they function in general C programming and their advanced, optimized use in embedded systems. Embedded systems demand deterministic behavior and tightly controlled memory usage, and structures play a vital role in organizing data effectively. The goal of this documentation is not only to understand how to define and use structures but also to understand their implications on memory alignment, optimization, and access time, particularly in memory-constrained embedded environments.

Through detailed explanations, real-world scenarios, best practices, and optimized coding techniques, this book will guide you through using structures as a critical building block in embedded firmware design. You'll learn how to define clean interfaces, manage hardware registers, and organize application data for optimal performance. Each section includes in-depth theoretical background, code snippets, and embedded use cases, making it a practical knowledge transfer resource for both beginners and professionals.

 

Structures in Embedded C Programming

What are Structures?
A structure in C is a user-defined data type that allows combining variables of different types under one name. This is especially useful when managing logically grouped data.

struct SensorData {
    int temperature;
    float humidity;
    char status;
};

Each instance of this structure can hold a temperature reading, a humidity value, and a status flag—making it easier to manage sensor data together.


Embedded Context: In embedded systems, sensors or devices often produce multiple data points at once. Structures allow you to organize this data neatly and access it efficiently.

Need for Structures in Embedded Systems
Structures are fundamental in embedded C programming for organizing data logically and interfacing with hardware.

Common Use Cases:

Representing hardware registers
Grouping system or device state variables
Structuring communication packets (e.g., UART, I2C, SPI)
Handling configuration or calibration parameters

struct GPIO_Registers {
    uint32_t MODER;
    uint32_t OTYPER;
    uint32_t OSPEEDR;
    uint32_t PUPDR;
    uint32_t IDR;
    uint32_t ODR;
};

#define GPIOA ((volatile struct GPIO_Registers*)0x48000000)

Tips:

Use volatile for hardware-mapped structures to prevent compiler optimizations.
Use structures to keep the code modular and maintainable.

Structure vs Array vs Union

Feature			  Structure		   Array			Union
--------		------------		--------------		   -------------------
Data Types		Different types		Same type only		Different types (1 at a time)
Access Pattern		Named fields		Indexed access		Named fields (overlap)
Memory Usage		Sum + possible padding	Size × count		Size of the largest field


union Data {
    uint16_t raw;
    struct {
        uint8_t low;
        uint8_t high;
    };
};

Tips:
Use unions for memory efficiency when multiple data views share the same memory.
Structures improve code readability in device drivers.


Structure Declaration and Initialization

Basic Syntax

struct Motor {
    uint16_t speed;
    uint8_t direction;
    char mode;
};

To create a variable:

struct Motor m1;

To access fields:

m1.speed = 200;
m1.direction = 1;
m1.mode = 'F';

Use typedef to simplify usage:

typedef struct {
    uint16_t speed;
    uint8_t direction;
    char mode;
} Motor;
Motor m2;
Initialization Techniques

Static Initialization:

Motor m3 = {120, 0, 'R'};
Designated Initialization:

Motor m4 = {
    .speed = 150,
    .direction = 1,
    .mode = 'F'
};

Tips for Embedded Systems:

Prefer constant initialization for static or global structures.
Avoid dynamic allocation in systems with limited memory.
Organize initialization constants in ROM using const structures.

Design Considerations in Embedded Context

Use Fixed-Width Types: Avoid ambiguity by using types like uint8_t, uint16_t, int32_t, etc.
Minimize Stack Usage: Structures can consume significant memory. Consider global/static allocation where necessary.

Separate Configuration and Runtime Data: Use one structure for configuration data and another for runtime variables.

Efficient Access: Group frequently accessed variables together to benefit from cache or memory alignment.
Memory Layout of Structures
Padding and Alignment
Compilers align structure members to improve access efficiency, inserting padding as needed.

struct Example {
    char a;     // 1 byte
    int b;      // 4 bytes (aligned)
};
Memory layout:

a (1 byte)
padding (3 bytes)
b (4 bytes)
Total: 8 bytes, not 5.

Optimization: Reorder members to reduce padding:

struct Example {
    int b;
    char a;
};

sizeof() and Memory Optimization

Use sizeof() to determine the actual memory usage of structures.

Tips:
Optimize field order to reduce padding.
Avoid unnecessary fields or nesting where not needed.
Prefer types with natural alignment for your CPU architecture.
Embedded Context: Ensure structure size is suitable for communication protocols or memory-mapped register layouts.

Structure Packing in Embedded Systems
To match exact memory layouts, structure packing can be used to remove padding.

#pragma pack(1)
struct PackedData {
    char type;
    uint16_t id;
    uint8_t value;
};
#pragma pack()

When to Use Packing:

Register definitions
Network/communication protocols (CAN, UART, SPI)
File system metadata
Memory-mapped data with strict format

Caution:

Misaligned memory access can cause CPU faults or slow execution on some architectures. Always verify CPU support for unaligned access before using packed structures.

Best Practices and Tips for Structures in Embedded C
Use typedef for cleaner code and better abstraction.
Use const to store static configuration structures in ROM instead of RAM.
Use bitfields to save space for flags:

struct Status {
    uint8_t power : 1;
    uint8_t error : 1;
    uint8_t ready : 1;
};

Use unions to overlap memory when needed:

union Packet {
    struct {
        uint8_t header;
        uint8_t data[4];
    };
    uint32_t full;
};

For abstraction, use structures with function pointers in driver development:

struct Driver {
    void (*init)(void);
    void (*read)(uint8_t*);
    void (*write)(uint8_t);
};

Always verify structure alignment, padding, and size when interfacing with hardware or protocols.
 
Structures in C - Advanced Topics
Structure Pointers and Memory Access

Pointer to Structure
A pointer to a structure allows indirect access to the structure’s members via a memory address.

Syntax:

struct Device {
    uint8_t id;
    uint16_t value;
};

struct Device d1;
struct Device *ptr = &d1;

Why use structure pointers in embedded systems:

Efficient memory usage (especially on low-RAM systems).
Required for dynamically accessed hardware-mapped regions.
Enables passing large structures without copying overhead.
Embedded Tip: When accessing memory-mapped hardware (e.g., register banks), structures are often accessed via pointers cast to specific memory addresses.
Arrow Operator Usage (->)
Used to access members of a structure through a pointer.

ptr->id = 10;          // Equivalent to (*ptr).id = 10;
uint16_t val = ptr->value;

When to use:

Anytime you deal with pointers to structures (e.g., in device drivers, dynamic memory access, or linked lists).
Structure Access via Pointers in Peripheral Programming
Example: Accessing memory-mapped I/O registers

typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
} GPIO_TypeDef;

#define GPIOA ((GPIO_TypeDef *)0x40020000)

GPIOA->MODER |= (1 << 0);   // Set bit 0 in MODER register
Why this matters:

Direct control of hardware.
Structured access improves readability and maintainability of register-level code.
Tips:

Always use volatile for hardware registers.
Define base addresses using #define and typecast to pointer of structure.
Nested Structures and Arrays within Structures
Nested Structure Design
A structure can contain another structure as a member.

struct Position {
    float x;
    float y;
};

struct Robot {
    uint8_t id;
    struct Position location;
};

Accessing members:

robot.location.x = 12.5;
Why use it:

For hierarchical data (e.g., a device with multiple sensors, or a protocol with nested headers).
Arrays of Structures and Structures with Arrays
Array of Structures:

struct Sensor {
    uint16_t value;
    char name[10];
};

struct Sensor sensors[5];  // Five sensors
Structure with Arrays:

struct DataBuffer {
    uint8_t data[128];
    uint16_t length;
};
Embedded Use Case:

Arrays of structures are useful for managing multiple sensors or devices.
Structures with arrays are useful in communication buffers (e.g., UART RX buffer, SPI frame buffer).
Tip:

Prefer statically sized arrays for deterministic memory use in embedded systems.
Use macros to define size constants to simplify changes.
Use Cases in Protocol Stacks and Sensor Data

Protocol Stacks:

struct IP_Header {
    uint8_t version;
    uint8_t ttl;
    uint16_t length;
};

struct Packet {
    struct IP_Header ip;
    uint8_t payload[64];
};

Sensor Aggregation:

struct SensorReading {
    uint32_t timestamp;
    float temperature;
    float humidity;
};

struct SensorLog {
    struct SensorReading readings[100];
};

Tip: For protocol parsing, align fields with protocol specification and use packing if needed to match bit/byte layout.

Structures and Functions
Passing Structures to Functions
By Value (copied):

void displayData(struct Sensor s);
Pros:

Safer (original data remains unchanged)
Cons:

Consumes stack memory (bad for large structures)
By Reference (via pointer):

void updateSensor(struct Sensor *s);
Pros:

Efficient (no copying)
Allows direct modification
Cons:

Care needed to avoid unintended side effects
Best Practice: In embedded systems, always prefer passing pointers to structures to save memory and CPU cycles.

Returning Structures from Functions
Allowed in C, though it may cause extra copying:

struct Sensor getSensorData(void) {
    struct Sensor s = {100, 23.4, 45.0};
    return s;
}

Tip: Use with small structures only. For larger data, return via pointer.

Alternative:

void getSensorData(struct Sensor *s) {
    s->value = 100;
    s->temperature = 23.4;
}

Call by Value vs Call by Reference
-------------------------------------
Method				Description			Embedded Suitability

Call by Value		Copies entire structure			Less efficient, safer
Call by Reference	Passes address, modifies original	More efficient, widely used

Tips:

Use const struct * if you don’t want the function to modify the structure.
Avoid value passing for structures larger than a few bytes.

Final Notes & Practical Tips

Use typedef for convenience and abstraction.
Stick to fixed-width types for portability (uint8_t, uint16_t, etc.).
Use volatile for hardware-mapped structures.
Document your structure layout for hardware register mappings.
Align structure members for optimal size and access performance.
Use tools like sizeof() and offsetof() to analyze structure layout in memory.
 

Structures and Memory Techniques

Unions and Structures

Structure vs Union Comparison

A structure (struct) groups together different variables under one name. Each member has its own memory location, so the total size of the structure is roughly the sum of all its members (plus possible padding). This makes structures ideal when you need to store several related pieces of data simultaneously.

A union, by contrast, overlays all its members on the same memory location. This means the total size of the union equals the size of its largest member. All members share this memory, so only one member can be used at a time. Writing to one member and reading another can reinterpret the same memory differently.

This key difference makes unions ideal when:

You need to save memory.
Only one of the possible data types is relevant at a time.
You want to interpret the same data buffer in different ways.
Example:

Suppose you have sensor data that can be either an integer or a float. Instead of using 8 bytes (4 bytes for int + 4 for float), a union allows you to use only 4 bytes.

Use of Union for Memory Optimization
Embedded systems often have strict RAM constraints. Unions let you overlap multiple data representations to reduce memory footprint.

Consider a communication buffer:

The same 4 bytes could represent raw data, a checksum, or a structured command.
Using a union allows flexible data handling without extra copies.
However, care must be taken to keep track of which union member is valid to avoid incorrect interpretation.

Real-Time Data Buffers and Protocol Handling
In real-time embedded communication, data packets are received as raw byte streams. Unions allow you to overlay structured fields on the raw data buffer to parse protocol headers and payloads efficiently.

For example:

You receive 8 bytes from a UART buffer.
A union maps those 8 bytes to a structured header with fields like command, length, and checksum.
This reduces the need for copying or extra parsing steps.
This approach is widely used in device drivers and protocol stacks to simplify packet processing.

Bit-fields in Structures
Introduction to Bit-fields
Bit-fields allow the definition of structure members that occupy a specific number of bits, rather than the default whole bytes. This is particularly useful in embedded systems where hardware registers often expose control/status flags in single bits or groups of bits.

Syntax and Bit Allocation
You define bit-fields inside a structure by specifying the number of bits after a colon:

struct Flags {
    unsigned int flag1 : 1;  // 1 bit
    unsigned int flag2 : 2;  // 2 bits
    unsigned int flag3 : 5;  // 5 bits
};

The compiler packs these bits into one or more underlying integer units (commonly 1, 2, or 4 bytes depending on the platform). This allows efficient storage and easy access to individual bits.

Real-Time Use Case: Status Register Representation
Most microcontrollers expose hardware registers as bit-packed fields. Instead of manually masking bits, bit-fields let you write readable code to set, clear, or check individual bits.

Example: UART status register with error flags and ready flags, each represented by 1 bit.

Advantages:

Clear, maintainable code
Compact storage
Direct mapping to hardware registers
Caution: Bit-field ordering and packing is implementation-defined by the compiler, so bit-fields should be used carefully in code that requires strict layout, especially across different compilers or architectures.

Structure Padding, Alignment, and Packing
Why Padding Happens
Processors access memory more efficiently when data is aligned on specific byte boundaries — usually multiples of the data size or the processor’s word size. For example, a 4-byte integer is typically best accessed when its address is divisible by 4.

To satisfy these alignment requirements, compilers insert padding bytes between structure members or at the end of structures. This ensures members start at proper boundaries, even if it means wasting some bytes.

Example:

struct Example {
    char a;     // 1 byte
    // 3 bytes padding here to align next int
    int b;      // 4 bytes, aligned at 4-byte boundary
};

Without padding, accessing b might cause slower operations or hardware faults on some architectures.

Controlling Padding using #pragma pack
Sometimes you need to control or remove padding to ensure structure size matches a specific layout, such as hardware registers or communication packet formats.

#pragma pack directives tell the compiler to reduce or eliminate padding:

#pragma pack(push, 1)
struct Packed {
    char a;
    int b;
};

#pragma pack(pop)

This forces the compiler to pack the structure with 1-byte alignment, making sizeof(struct Packed) equal to 5 bytes instead of 8.

Implications in Communication Protocols and Register Maps
Communication protocols expect fixed-size packets with exact field placements.
Hardware registers require matching the layout and alignment in memory-mapped IO.
Improper padding can lead to corrupted data or failed communication.
Warning: Overpacking can cause unaligned memory accesses, which may be slower or cause exceptions on some CPUs.

Function Pointers in Structures
Function Pointers in Structures
A function pointer stores the address of a function and can be called later through that pointer. Embedding function pointers inside structures enables polymorphism and flexibility.

This technique is common in embedded device drivers and middleware, allowing different hardware or modules to be controlled through a uniform interface.

Callback Handlers

Callbacks are functions passed as pointers to other functions or structures. When an event occurs (like an interrupt or timer expiry), the callback is invoked to handle it.

Example:

A timer structure holds a pointer to a user-defined callback function.
When the timer expires, the system calls the callback via the pointer.
This mechanism allows decoupling event handling logic from hardware-specific code.

Real-Time Scenario
Device drivers often provide operations via a table of function pointers:

struct DeviceOps {
    int (*open)(void);
    int (*close)(void);
    int (*read)(char *buf, int len);
};

Different devices implement these functions differently, but higher-level code can call dev->open(), dev->read(), etc., without knowing the device specifics.

This design supports modular, scalable embedded software.

Dynamic Memory with Structures
malloc(), free() in Embedded Context
Dynamic memory allocation (malloc and free) allows allocating and freeing memory at runtime. While common in desktop programming, in embedded systems it requires caution due to:

Limited RAM
Fragmentation risks
Unpredictable timing (non-deterministic latency)
When used, dynamic memory helps manage variable-sized data or structures like linked lists, buffers, and queues.

Linked Lists and Queues using Structures
Dynamic memory is ideal for implementing linked data structures:

struct Node {
    int data;
    struct Node *next;
};

Such data structures are useful for:

Managing sensor data buffers with variable lengths
Event queues in RTOS or bare-metal systems
Task lists and message passing
Memory Pool Management

To avoid fragmentation and ensure deterministic behavior, many embedded systems implement memory pools:

Pre-allocate a large block of memory.
Divide it into fixed-size chunks (for example, for nodes).
Manage allocation and deallocation internally.

This approach ensures predictable allocation times and better memory control than general malloc/free.




Reference
-----------------------


https://www.youtube.com/watch?v=IPLPISOXvF0&list=PLBlnK6fEyqRiteqwlMLXYtZ16xXDR7MO0&index=3



https://www.youtube.com/watch?v=LpHnHRI6gLc


